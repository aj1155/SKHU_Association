여러개의 명령어를 사용하기위해는 script를 사용

/bin/sh borne shell을 의미
/bin/bash bash shell을 의미

#!/bin/bash--> 밑에있는 스크립트가 bash 쉘이라는것을 의미

만약 생략하고 실행을 했을시 현재 내가 실행하고있는 쉘에서 스크립트를 실행
보통은 생략하지 않는다.

bash shell의 borne shell의 문법을 모두 사용할수있다.

shell script에서 주석은 #을 사용
but #! /bin/bash는 주석이아니고 스크립트에 사용할 shell을 의미

echo $HOME --> HOME의 주소

echo $PATH --> 자기계정의 주소

변수선언시 그냥 a=10 or a="10" or a='10'
	""나 ''를 사용하는 이유는 공백문자가 들어가면 인식을 못하기 때문에
값을 얻어오려면 $표시를 사용

echo home=$HOME
경로가 저장
ehco에서는 $가 나오면 변수로 취급

$$ 현재 실행중인 shell의 프로세스 ID
$0 현재 실행중인 shell script의 이름을 나타낸다
$1..$9 명령어의 인자(매개변수) ex) cp a b c
$* 모든 매개변수를 나타낸다
$? 마지막 실행한 명령어의 Exit 상태(성공했을때는 0 실패했을때는 1)

스크립트 실행시 ./을 앞에 붙여준다

""와 ''는 둘다 공백을 포함하지만 기능은 다르다
''는 와일드카드도 맞고, 변수의 값치환도 맞고, command substitution도 맞다
""는 와일드카드만 맞다.

echo 3 * 4 = 12
3을 추력하고 *는 와일드키이기때문에 현재폴더안의 파일들을 모두 출력하고 4출력후 =출력 12 를 출력
ehco 3 - 2 = 1
은 그냥 3 - 2 = 1 을 출력
""나 ''을 사용시 와일드키를 무시하고 그대로 출력해준다.

echo 'my name is $name' $name을 변수로 취급하지않고 그대로 출력해준다
echo "my name is $name" $name을 변수로 인식해서 출력

''는 변수 혹은 명령어 모두 무시 모두 string으로 처리-->모두 무시해준다.
""는 변수 혹은 명령어 모두를 인식해 실행-->와일드 카드만 무시한다.

job control --> 프로세스 관련 명령어 

ps -->현재 실행되어있는 프로세스를 나타낸다.
	관리자들이 보통 실행하는 option ps -ef

	1번째 사용자 이름
	2번째 프로세스 아이디
	3번째 부모 프로세스 아이디
	4번째 
	5번재
	6번째
	7번째
	sleep 초 입력시 4초 동안 멈췄다가 다음 명령어 실행
kill --> 프로세스를 죽이는 명령어
	kill -9 거의 이것만 사용
	-9를 사용해야 확실하게 죽일수 있다.
	최상위 부모프로세스를 죽여버리면 모든 프로세스가 죽는다.
	ex) kill -9 프로세스 번호
	
wait --> 

background로 실행시 comman작업을 계속 진행 가능

$PATH 경로명이다


subshells
쉘을 하나 실행하면은 자식 쉘을 하나 생성해서 거기서 실행
ex) ls을 입력시
	자식 쉘을 생성해 실행하고 실행이 끝나면 삭제
	sleep을 입력시 자식 쉘을 생성해서 자식쉘에서 sleep을 실행 부모쉘도 sleep

backgorund로 실행시 자식 쉘을 생성해놓고 부모쉘로 돌아오기 때문에 계속 사용가능
환경변수는 대부분 부모의 것을 물려받는다 
